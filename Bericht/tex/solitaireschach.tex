\documentclass[
	12pt,
	a4paper,
	BCOR10mm,
	%chapterprefix,
	DIV14,
	listof=totoc,
	bibliography=totoc,
	headsepline
]{scrreprt}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{ngerman}

\usepackage{lmodern}

\usepackage[footnote]{acronym}
\usepackage[page,toc]{appendix}
\usepackage{fancyhdr}
\usepackage{float}
\usepackage{graphicx}
\usepackage[pdfborder={0 0 0}]{hyperref}
\usepackage[htt]{hyphenat}
\usepackage{listings}
\usepackage{lscape}
\usepackage{microtype}
\usepackage{nicefrac}
\usepackage{subfig}
\usepackage{textcomp}
\usepackage[subfigure,titles]{tocloft}
\usepackage{units}

\lstset{
	basicstyle=\ttfamily,
	frame=single,
	numbers=left,
	language=C,
	breaklines=true,
	breakatwhitespace=true,
	postbreak=\hbox{$\hookrightarrow$ },
	showstringspaces=false,
	tabsize=4
}

\renewcommand*{\lstlistlistingname}{Listingverzeichnis}

\renewcommand*{\appendixname}{Anhang}
\renewcommand*{\appendixtocname}{Anhänge}
\renewcommand*{\appendixpagename}{Anhänge}

\begin{document}

\begin{titlepage}
	\begin{center}
		{\titlefont\huge Solitaire-Schach\par}

		\bigskip
		\bigskip

		{\titlefont\Large --- Praktikumsbericht ---\par}

		\bigskip
		\bigskip

		{\large Arbeitsbereich Wissenschaftliches Rechnen\\
		Fachbereich Informatik\\
		Fakultät für Mathematik, Informatik und Naturwissenschaften\\
		Universität Hamburg\par}
	\end{center}

	\vfill

	{\large \begin{tabular}{ll}
		Vorgelegt von: & Kira Duwe\\
		E-Mail-Adresse: & \href{mailto:adresse@email.de}{0duwe@informatik.uni-hamburg.de} \\
		Matrikelnummer: & 6225091 \\
		Studiengang: & Informatik \\
		\\
			Vorgelegt von: & Enno Zickler\\
		E-Mail-Adresse: & \href{mailto:adresse@email.de}{0zickler@informatik.uni-hamburg.de} \\
		Matrikelnummer: & 6250134 \\
		Studiengang: & Informatik \\
		\\
		%Erstgutachter: & Name des Erstgutachters \\
		%Zweitgutachter: & Name des Zweitgutachters\\ \\
		Betreuer: & Julian Kunkel \\
		\\
		Hamburg, den 30.09.2013
	\end{tabular}\par}
\end{titlepage}

\chapter*{Abstract}

\thispagestyle{empty}

TODO: Hier kommt eine kurze Beschreibung der nachfolgenden Arbeit hin.

%Inhaltsverzeichnis
\tableofcontents

%Kapitel 1
\chapter{Einleitung}
\label{Einleitung}

\section{Spielregeln}
Solitaireschach ist eine Kombination aus der Spiellogik von Solitaire und 
den Zugregeln des Schachs. Es wird allein auf einem 4x4 großen Brett mit einer gegebenen Startaufstellung gespielt. Diese ergibt sich zufällig aus der Figurenmenge des Schachs, wobei nur zwei Bauern vorhanden sind. Es gibt also eine Dame,
einen König, zwei Springer, zwei Läufer, zwei Türme und zwei Bauern. 
Zu Beginn kann eine beliebige Kombination dieser Figuren auf dem Brett stehen, wobei mindestens zwei und maximal zehn Figuren benutzt werden.
Ungültig wären Spielbretter bei denen zum Beispiel zwei Damen aufgestellt sind.


Ziel ist es, dass am Ende des Spiels nur noch eine einzige Figur auf dem Spielbrett steht. Pro Zug muss genau eine Figur gezogen und damit eine andere geschlagen werden.
Die Figuren ziehen nach folgenden Regeln:
\begin{itemize}
\item Bauer: 
Der Bauer kann auf eines seiner benachbarten Diagonalfelder ziehen. Im Gegensatz zum Schach ist hier jede Zugrichtung möglich.
\item Turm: Der kann beliebig viele Felder (mindestens eines) auf der x- oder auf der y-Koordinate seines Feldes ziehen.
\item Läufer: Der Läufer kann beliebig viele Felder (mindestens eines) auf den Diagonalen seines Feldes ziehen.
\item Springer: Der Springer ist die einzige Figur, die über andere Figuren auf ihrem Weg hinwegspringen kann. Erst die Figur am Ende des Zuges wird geschlagen. Es gibt zwei mögliche Züge. Entweder der Springer wird zwei Felder auf der x-Koordinate und eines auf der y-Koordinate gezogen oder ein Feld in x-Richtung und zwei in y-Richtung. 
\item König: Der König kann genau ein Feld weit ziehen, wobei alle benachbarten Felder möglich sind. Er stellt also eine Mischung aus Bauer und eingeschränktem Turm dar.
\item Dame: Die Dame ist in der Lage beliebig viele Felder auf den Diagnoalen oder auf einer der beiden Achsen zu ziehen. Damit ist sie eine Kombination aus Läufer und Turm.
\end{itemize}


\section{Aufgabenstellung}

Das Spiel bietet nun eine enorme Vielfalt an gültigen Startpositionen und resultierenden Folgebrettern.
Uns faszinierte daher die Frage, wie viele mögliche Startbelegungen es gäbe und welche davon lösbar wären.
Dieses Problem wollten wir gern für eine variable Spielbrettgröße untersuchen und nicht nur für den Fall des 4x4-Brettes.
Sollten diese Aufgabenstellungen nicht umfangreich genug sein, so hätten wir uns noch mit der Ausgabe der möglichen Lösungen beschäftigt und einer Aufzeichnung der Lösungswege.
Das Programm sollte also alle gültigen Startpositionen erzeugen - und zwar nur die gültigen - sowie eine Berechnung durchführen, welche dieser entstandenen Bretter lösbar sind.


\section{Begrifflichkeiten}
Hier eine Definition der im folgenden gebrauchten Begriffe:
\begin{itemize}
	\item Spielbrett: die aktuelle Belegung der einzelnen Felder
	\item Spielfeld: genau ein Einzelsegment des Spielbrettes
	\item Spielbrettbreite: x-Koordinate des Spielbrettes (links-rechts)
	\item Spielbretthöhe: y-Koordinate des Spielbrettes (oben-unten)
	\item Felderanzahl= Spielbrettbreite x Spielbretthöhe
\end{itemize}


%Kapitel 2
\chapter{Entwurf \& Implementierung}
\label{Entwurf}

\section{Entwurf}
\section{Probleme}
Während des Entwurfs und der Implementierung traten in einigen Bereichen Schwierigkeiten auf.
\subsection{Spielbretterzeugung}
Zunächst einmal bestand der Anspruch nicht nur einen korrekten sondern auch einen effizienten Algorithmus für die Erzeugung der Spielbretter auf einer variablen Spielbrettgröße zu finden.
Es sollten also garantiert alle Spielbretter erzeugt werden, ohne dass doppelte entstehen.

\subsection{Modellierung und Speicherung der Spielbretter}
Eine obere Grenze für die Anzahl der möglichen Startbelegungen bietet eine Abschätzung mit der Faktoriellen:\\
16 * 15 * 14 * 13 * 12 * 11 * 10 * 9 * 8 * 7 = 29 059 430 400

Dort sind zwar noch die doppelten Felder enthalten, die dadurch entstehen, dass zwischen den Figuren vom gleichen Typ nicht unterschieden wird, dennoch bietet es eine gute Einschätzung der Größenordnung.
Damit ergab sich die Frage, wie man die Spielbretter möglichst speichereffizient modellieren kann und wie eine sinnvolle Speicherverwaltung einer derart großen Menge aussehen könnte, die später auch noch für den parallelen Zugriff geeignet wäre.

\subsection{Berechnung der Spielbretter}
Um von einer gültigen Startbelegung zu der Aussage "Das Brett ist lösbar." zu kommen,braucht man mindestens einen im Maximalfall aber 9 Berechnungsschritte und zwar für jedes Spielbrett. Da die Zahl der möglichen Spielbretter ohnehin schon sehr groß ist, musste also eine Berechnung gefunden werden, die sehr effizient arbeitet.


\subsection{Lastungleichheit}
Aufgrund der Abhängigkeit der Berechnungszeit von der Anzahl der möglichen Züge ergibt sich eine deutliche Lastungleichheit.



\section{Implementierung}
\subsection{Darstellung der Spielbretter}
Wir schwankten lange zwischen zwei verschiedenen Ansätzen.
Eine Möglichkeit ist die Speicherung als zweidimensionales Array, das eine deutlich intuitivere Handhabung mit sich bringt. Allerdings ist es deutlich größer, was den benötigten Speicher angeht.
Das kleinste zur Verfügung stehende wäre ein 16 elementiges Char-Array. 
Es braucht also für den Fall 4x4:  16*8bit = 128 bit.

Um eine möglichst kompakte und damit speicher- und zugriffseffiziente Darstellung der Spielbretter zu erhalten, entschieden wir uns für eine Oktaldarstellung. Diese benötigt 64 bit und bietet die Möglichkeit, Spielbretter bis zu einer Größe von 3 x 7 zu codieren. 
Das 4x4 Brett braucht also nur 64 bit und damit die Hälfte im Vergleich zum Array.

Codierung:\\
Die letzte Stelle der Zahl ist das Feld des Brettes mit der Nummer 0.
Jede Stelle der Oktalzahl bzw. drei Stellen der Binärzahl ($ 2^3 = 8 $) repräsentiert also genau ein Feld des Spielbrettes. Für die Spielfiguren führten wir folgende Codierung ein:
\begin{itemize}
\item 0 = leeres Feld
\item 1 = Bauer
\item 2 = Turm
\item 3 = Läufer
\item 4 = Springer
\item 5 = König
\item 6 = Dame
\end{itemize}

Die Felder des Spielbrettes nummerierten wir von 0 - Felderanzahl-1 durch.
\begin{table}
	\begin{center}
		\begin{tabular}{|c|c|c|c|}\hline
		 0 &  1 &  2 &  3 \\ \hline
		 4 &  5 &  6 &  7 \\ \hline
		 8 &  9 & 10 & 11 \\ \hline
		12 & 13 & 14 & 15  \\ \hline
		\end{tabular}
	\end{center}
	\caption{Nummerierung der Spielfelder}
	\label{table:Tabelle1}
\end{table}

Hier ein Beispiel wie für die Darstellung eines Spielbrettes als Oktalzahl.
Das Spielbrett:  3032 4124 0650 0010 entspricht dem in der Tabelle dargestellten.
\begin{table}
	\begin{center}
		\begin{tabular}{|c|c|c|c|}\hline
		 0 &  1 &  0 &  0 \\ \hline
		 0 &  5 &  6 &  0 \\ \hline
		 4 &  2 &  1 & 4 \\ \hline
		 2 &  3 &  0 &  3 \\ \hline
		\end{tabular}
	\end{center}
	\caption{Spielbrett 3032 4124 0650 0010}
	\label{table:Tabelle1}
\end{table} 

Diese Art der Repräsentation orientiert sich an dem gängigen Standard für die Speicherung von Schachbrettern. Dort wird eine Binärzahl mit der Größe von  64 bit benutzt, um darstzustellen, welche Felder belegt sind.
Zwei weitere werden benötigt, um die Figurentypen zu speichern.
Da wir aber ein deutlich kleineres Spielbrett betrachten, entschieden wir uns dafür nur eine Zahl zu benutzen.



\subsection{Erzeugung der Spielbretter}

Die Erzeugung erfolgt über ineinander verschachtelte for-Schleifen.
Der naive Ansatz zählt für jede Figur jeweils von 0 bis Spielbrettgröße.
Da aber zwischen den doppelten Figuren (Springer, Läufer, Turm, Bauer) nicht unterschieden wird, ist es möglich an dieser Stelle zu optimieren.
So beginnt die jeweils zweite Figur die for-Schleifen erst ab der Position der jeweils ersten Figur zu durchlaufen, da ansonsten ein bereits erzeugtes Spielbrett erneut durchlaufen würde.
Eine weitere Optimierung ist möglich, indem alle weiter innen liegenden Schleifendurchläufe abgeschnitten werden, sobald das betrachtete Feld nicht frei ist. Es wird unabhängig vom Typ der Figur niemals möglich sein, diese auf ein bereits belegtes Feld zu setzen.

\begin{lstlisting}[caption={Erzeugung der Spielbretter}, label={lst:example1}]
//Schleife Dame
for(posDame = 0; posDame <= anzahlFelder; posDame++)
{	
	if(positionDame<anzahlFelder)
    {
         setze Dame;
         anzahlFiguren ++;
    }
    
    //Schleife Koenig
    for(posKoenig = 0; posKoenig <= anzFelder; posKoenig++)
    {	
    	 // uebernehmen der bisher gesetzen Figuren
         spielbrettKoenig = spielbrettDame;
         // uebernehmen der bisherigen Figurenanzahl
         anzFigurenK = anzFigurenD;
                    
         if(!(anzFigurenK < maxFiguren))
         {
             setze keinen Koenig;
         }
                    
                    
         if(feldFrei(posKoenig, spielbrettKoenig))
         {
              if(posKoenig<anzFelder)
              {
                   setze Koenig;
                   anzahlFiguren ++;
              }
              
              //Schleife 1. Springer 	
              for(posSpringer = 0; posSpringer <= anzFelder; posSpringer ++)
              {
              		if(!(anzFigurenS < maxFiguren))
              		{
              			setze keinen Springer;
              		}
              		if(feldFrei(posSpringer, spielbrettSpringer))
         			{
              			if(posSpringer < anzFelder)
              			{
                  			 setze Springer;
                  			 anzahlFiguren ++;
              			}
              		
              			//Schleife 2. Springer
              			for(posSpringer2=posSpringer1; posSpringer2<=anzFelder; posSpringer2++)
              			...
              			
              		 	 //Schleife 1. Laeufer
           			 	 ...
       				 	 //Schleife 2. Laeufer
          				  ...
               		 	 //Schleife 1. Turm
           			 	 ...
       				 	 //Schleife 2. Turm	          				 	 							 ...
              		 	 //Schleife 1. Bauer
       				 	 ... 
              			 //Schleife 2. Bauer
              			 for(Bauer2)
              			 {
              				if(! <)
              				if(frei)
              				{
              					 if(<)
              				 	 { 
              				 	 	setze Bauer2;
              				 	 }
              				 	 
              				}
              			
              			}
              	 	}
               }
         }
     }
}
\end{lstlisting}
 

//TODO: Pseudocode überarbeiten
//TODO: muss das abspeichern mit rein?
      


\subsection{Berechnung der Spielbretter}
Um die bereits berechneten Lösungen weiter zu verwenden, findet die Berechnung in Abhängigkeit der auf dem Brett befindlichen Figurenanzahl statt.
Zunächst werden alle Bretter mit einer Figur als lösbar vermerkt.
Es findet nun eine ebenenweise Berechnung statt, bei der nach der Figurenanzahl aufgestiegen wird. So kann für jedes Spielbrett einer höheren Ebene überprüft werden, ob daraus ein lösbares Brett entstehen kann. Dies ist eine erhebliche Optimierung, da ohne diese Wiederverwendung im schlechtesten Fall noch acht weitere Berechnungen stattfinden müssten. 

Für die Berechnung werden die Spielbretter nicht nur in der Oktaldarstellung sondern auch als Array vorgehalten. 
Das hat den Vorteil, dass die Abfragen zur Überprüfung ob, eine Spielfigur sich nach einem Zug auch noch auf dem Spielbrett befindet, sehr viel übersichtlicher und verständlicher werden. 
Denn eine für verschiedene Spielbrettgrößen passende Abfrage ist auf Oktalzahlen zu aufwändig.

Es findet also zunächst eine Umwandlung in die Arraydarstellung statt.
(siehe Listing~\ref{lst:example1})
\begin{lstlisting}[caption={Umwandlung in Arraydarstellung}, label={lst:example1}]  
// Berechnung der Arraydarstellung aus Oktaldarstellung einfacher fuer die 
// Ueberpruefung der Spielbrettgrenzen*/
for(x=0; x < SpielbrettBreite; x++)
{
    for(y=0; y < SpielbrettHoehe; y++)
    {   
		param.spielbrett_array[x][y] = 
		(spielbrett >> ((x+(y*SpielbrettBreite)) * 3)) % 8;
        }
    }
\end{lstlisting}


Das daraus entstandene zweidimensionale Array wird nun also Feld für Feld überprüft, ob dort eine Figur steht. Ist dies der Fall wird berechnet, ob es für diese Figur mögliche Züge gibt, die zu einem lösbaren Brett führen.
(siehe Listing~\ref{lst:example2})
\begin{lstlisting}[caption={Berechnung eines Spielbrettes}, label={lst:example2}]
 for(x=0; (x < SpielbrettBreite) && (loesbar == 0); x++)
 {
     for(y=0; (y < SpielbrettHoehe) && (loesbar == 0); y++)
	 {   
		switch(param.spielbrett_array[x][y]){
			case DarstellungBauer:
				loesbar= berechneBauer(&param, x, y);
				break;
			case DarstellungTurm:
				loesbar = berechneTurm(&param, x, y);
				break;ringer(&param, x, y);
				break;
			case DarstellungKoenig:
				loesbar = berechneKoenig(&param, x, y);
				break;
			case DarstellungDame:
				loesbar = berechneDame(&param, x, y);
				break;
		}
	}
 }
\end{lstlisting}


Das Schlagen einer Figur geschieht auf der Darstellung als Oktalzahl.
Um die schlagende und die geschlagene Figur vom Brett zu löschen, wird die Oktalzahl mit einer Bitmaske aus Einsen verundet, die an den beiden entsprechenden Positionen eine 0 hat.
Anschließend wird die Figur an die neue Position geschrieben. 


(siehe Listing~\ref{lst:example3})
\begin{lstlisting}[caption={Schlagen einer Figur}, label={lst:example3}]
void schlageFigur()
{
einser_Bitmaske = 0xffffffffffffffffLL;

// Spielfiguren, geschlagene und schlagende, von Spielbrett loeschen 
// Von der Bitmaske wird "(7 << pos*3)" abgezogen, um an dieser Stelle 0 zu erzeugen 
	neues_spielbrett = spielbrett & 
	(einser_Bitmaske - (7 << pos*3) - (7 << neue_pos*3));
	
	// nach Schlagen Spielfigur neu  setzen 
	neues_spielbrett += (DarstellungFigur << neue_pos*3);
}

\end{lstlisting}



\subsection{Speicherung der Spielbretter}

Die ursprüngliche Speicherung der Spielbretter erfolgte nach der Figurenanzahl in verschiedenen Hashtabellen.
In diesen wurde hinterlegt, ob ein Spielbrett lösbar ist (1) oder nicht (0). Verwendet wurde hier ein directhash, da die Spielbrettrepräsentation bereits eindeutig ist.
Aufgrund der enorm großen Anzahl an gültigen Spielbrettern ist das Speichern all dieser 64bit-Integer aber nicht ohne weiteres möglich.

Also optimierten wir die Speicherung. Der nächste Schritt war die Verwendung der Hashtabelle als Set.
Es wurden also nur noch die lösbaren Bretter gespeichert. Damit entfiel die Speicherung des Wertes, der aufgrund der Signaturen der verwendeten Bibliothek (glib) ebenfalls 64 bit groß gewesen wäre, obwohl wir nur ein Bit benötigt hätten.
Im Laufe der Analyse stellte sich heraus, dass die Menge an lösbaren Bretter deutlich größer ist als die Menge der nicht lösbaren. Es gibt sogar Figurenanzahlen, bei denen Spielbretter lösbar sind(siehe Kapitel~\ref{Ergebnisse}).
Daher wird die Hashtabelle inzwischen als Set für die Speicherung der nicht lösbaren Spielbretter verwendet.

Bei einem 4x4-Spielbrett müssen von anfangs den 6.684.411.696 x 64bit x 2 = 855.604.697.088 bit inzwischen nur noch \\

TODO: anzahl nicht lösbarer Bretter bei 4x4

gespeichert werden. Das ist eine Verringerung um x Prozent.


Hashtabelle als set
\subsection{Parallelisierung}
\subsection{Kommunikation}


%Kapitel 3
\chapter{Ergebnisse}
\label{Ergebnisse}

Anzahl der gültigen Spielbretter für ein 4x4-Brett = 6.684.411.696 :\\
mit Figurenanzahl:  1 =         96 \\
mit Figurenanzahl:  2 =       4.080 \\
mit Figurenanzahl:  3 =     100.800 \\
mit Figurenanzahl:  4 =    1.594.320 \\
mit Figurenanzahl:  5 =   16.773.120 \\
mit Figurenanzahl:  6 =  118.198.080 \\
mit Figurenanzahl:  7 =  547.747.200 \\
mit Figurenanzahl:  8 = 1.589.187.600 \\
mit Figurenanzahl:  9 = 2.594.592.000 \\
mit Figurenanzahl: 10 = 1.816.214.400 \\

Anzahl lösbare Bretter 4x4\\

Der Anteil an nicht lösbaren Spielbrettern wird bei größerer Spielbrettgröße immer kleiner. Das hängt damit zusammen, ob eine Dame auf dem Brett platziert ist oder nicht. Je mehr Figuren auf dem Brett stehen, umso größer ist die Wahrscheinlichkeit, dass sich auch die Dame dort befindet. Und die Wahrscheinlichkeit, dass ein Brett lösbar ist, wächst mit der Zahl der aufgestellten Figuren, wenn auch eine Dame gesetzt ist. 
Das liegt an der großen Vielfalt an möglichen Zügen, die eine Dame hat.
So sind die Spielbretter mit zehn Figuren in der Größe 4x4 immer lösbar.

Wir können an dieser Stelle keinen formalen Beweis für die Korrektheit der Behauptung anführen, da jedoch die Menge der nicht lösbaren Bretter gleich blieb, unabhänig davon ob diejenigen mit zehn Figuren mitbetrachtet wurden oder nicht, brauchen diese also nicht mehr berechnet werden. 
\section{Laufzeiten}

\section{Lösungen pro Sekunde}

\section{Hashtablegröße}

\section{Speedup}

\section{Lastenverteilung}


%Kapitel 4
\chapter{Fazit}
\label{Fazit}


%Letzte Seite!
\newpage

\thispagestyle{empty}

\chapter*{}

\section*{Erklärung}

Ich versichere, dass ich die Arbeit selbstständig verfasst und keine anderen, als die angegebenen Hilfsmittel -- insbesondere keine im Quellenverzeichnis nicht benannten Internetquellen -- benutzt habe, die Arbeit vorher nicht in einem anderen Prüfungsverfahren eingereicht habe und die eingereichte schriftliche Fassung der auf dem elektronischen Speichermedium entspricht.

\smallskip

\bigskip
\bigskip
\bigskip

Hamburg, den 30.09.2013  \quad \dotfill

\end{document}
